import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * Pok√©API
 * All the Pok√©mon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.

## What is this?

This is a full RESTful API linked to an extensive database detailing everything about the Pok√©mon main game series.

We've covered everything from Pok√©mon to Berry Flavors.

## Where do I start?

We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.

This API will always be publicly available and will never require any extensive setup process to consume.

Created by [**Paul Hallett**](https://github.com/phalt) and other [**Pok√©API contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pok√©mon and Pok√©mon character names are trademarks of Nintendo.
    
 * OpenAPI spec version: 2.7.0
 */
import { useQuery } from '@tanstack/react-query';

import type { ApiV2EncounterConditionListParams as ApiV2EncounterConditionListParameters } from './schemas/api-v2-encounter-condition-list-params';
import type { ApiV2EncounterConditionValueListParams as ApiV2EncounterConditionValueListParameters } from './schemas/api-v2-encounter-condition-value-list-params';
import type { ApiV2EncounterMethodListParams as ApiV2EncounterMethodListParameters } from './schemas/api-v2-encounter-method-list-params';
import type { ApiV2PokemonEncountersRetrieve200Item } from './schemas/api-v2-pokemon-encounters-retrieve200-item';
import type { EncounterConditionDetail } from './schemas/encounter-condition-detail';
import type { EncounterConditionValueDetail } from './schemas/encounter-condition-value-detail';
import type { EncounterMethodDetail } from './schemas/encounter-method-detail';
import type { PaginatedEncounterConditionSummaryList } from './schemas/paginated-encounter-condition-summary-list';
import type { PaginatedEncounterConditionValueSummaryList } from './schemas/paginated-encounter-condition-value-summary-list';
import type { PaginatedEncounterMethodSummaryList } from './schemas/paginated-encounter-method-summary-list';

export type apiV2EncounterMethodListResponse = apiV2EncounterMethodListResponseSuccess;

/**
 * Methods by which the player might can encounter Pok√©mon in the wild, e.g., walking in tall grass. Check out Bulbapedia for greater detail.
 * @summary List encounter methods
 */
export type apiV2EncounterMethodListResponse200 = {
  data: PaginatedEncounterMethodSummaryList;
  status: 200;
};
export type apiV2EncounterMethodListResponseSuccess = {
  headers: Headers;
} & apiV2EncounterMethodListResponse200;

export const getApiV2EncounterMethodListUrl = (parameters?: ApiV2EncounterMethodListParameters) => {
  const normalizedParameters = new URLSearchParams();

  for (const [key, value] of Object.entries(parameters || {})) {
    if (value !== undefined) {
      normalizedParameters.append(key, value === null ? 'null' : value.toString());
    }
  }

  const stringifiedParameters = normalizedParameters.toString();

  return stringifiedParameters.length > 0
    ? `/api/v2/encounter-method/?${stringifiedParameters}`
    : `/api/v2/encounter-method/`;
};

export const apiV2EncounterMethodList = async (
  parameters?: ApiV2EncounterMethodListParameters,
  options?: RequestInit,
): Promise<apiV2EncounterMethodListResponse> => {
  const res = await fetch(getApiV2EncounterMethodListUrl(parameters), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: apiV2EncounterMethodListResponse['data'] = body ? JSON.parse(body) : {};
  return { data, headers: res.headers, status: res.status } as apiV2EncounterMethodListResponse;
};

export const getApiV2EncounterMethodListQueryKey = (
  parameters?: ApiV2EncounterMethodListParameters,
) => {
  return [`/api/v2/encounter-method/`, ...(parameters ? [parameters] : [])] as const;
};

export const getApiV2EncounterMethodListQueryOptions = <
  TData = Awaited<ReturnType<typeof apiV2EncounterMethodList>>,
  TError = unknown,
>(
  parameters?: ApiV2EncounterMethodListParameters,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterMethodList>>, TError, TData>
    >;
  },
) => {
  const { fetch: fetchOptions, query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getApiV2EncounterMethodListQueryKey(parameters);

  const queryFunction: QueryFunction<Awaited<ReturnType<typeof apiV2EncounterMethodList>>> = ({
    signal,
  }) => apiV2EncounterMethodList(parameters, { signal, ...fetchOptions });

  return { queryFn: queryFunction, queryKey, ...queryOptions } as {
    queryKey: DataTag<QueryKey, TData, TError>;
  } & UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterMethodList>>, TError, TData>;
};

export type ApiV2EncounterMethodListQueryError = unknown;
export type ApiV2EncounterMethodListQueryResult = NonNullable<
  Awaited<ReturnType<typeof apiV2EncounterMethodList>>
>;

export type apiV2EncounterMethodRetrieveResponse = apiV2EncounterMethodRetrieveResponseSuccess;
/**
 * Methods by which the player might can encounter Pok√©mon in the wild, e.g., walking in tall grass. Check out Bulbapedia for greater detail.
 * @summary Get encounter method
 */
export type apiV2EncounterMethodRetrieveResponse200 = {
  data: EncounterMethodDetail;
  status: 200;
};
export type apiV2EncounterMethodRetrieveResponseSuccess = {
  headers: Headers;
} & apiV2EncounterMethodRetrieveResponse200;
/**
 * @summary List encounter methods
 */

export function useApiV2EncounterMethodList<
  TData = Awaited<ReturnType<typeof apiV2EncounterMethodList>>,
  TError = unknown,
>(
  parameters: ApiV2EncounterMethodListParameters | undefined,
  options: {
    fetch?: RequestInit;
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterMethodList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV2EncounterMethodList>>,
          TError,
          Awaited<ReturnType<typeof apiV2EncounterMethodList>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & DefinedUseQueryResult<TData, TError>;

export function useApiV2EncounterMethodList<
  TData = Awaited<ReturnType<typeof apiV2EncounterMethodList>>,
  TError = unknown,
>(
  parameters?: ApiV2EncounterMethodListParameters,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterMethodList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV2EncounterMethodList>>,
          TError,
          Awaited<ReturnType<typeof apiV2EncounterMethodList>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError>;

export function useApiV2EncounterMethodList<
  TData = Awaited<ReturnType<typeof apiV2EncounterMethodList>>,
  TError = unknown,
>(
  parameters?: ApiV2EncounterMethodListParameters,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterMethodList>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError>;
export function useApiV2EncounterMethodList<
  TData = Awaited<ReturnType<typeof apiV2EncounterMethodList>>,
  TError = unknown,
>(
  parameters?: ApiV2EncounterMethodListParameters,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterMethodList>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError> {
  const queryOptions = getApiV2EncounterMethodListQueryOptions(parameters, options);

  const query = useQuery(queryOptions, queryClient) as {
    queryKey: DataTag<QueryKey, TData, TError>;
  } & UseQueryResult<TData, TError>;

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getApiV2EncounterMethodRetrieveUrl = (id: string) => {
  return `/api/v2/encounter-method/${id}/`;
};

export const apiV2EncounterMethodRetrieve = async (
  id: string,
  options?: RequestInit,
): Promise<apiV2EncounterMethodRetrieveResponse> => {
  const res = await fetch(getApiV2EncounterMethodRetrieveUrl(id), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: apiV2EncounterMethodRetrieveResponse['data'] = body ? JSON.parse(body) : {};
  return { data, headers: res.headers, status: res.status } as apiV2EncounterMethodRetrieveResponse;
};

export const getApiV2EncounterMethodRetrieveQueryKey = (id?: string) => {
  return [`/api/v2/encounter-method/${id}/`] as const;
};

export const getApiV2EncounterMethodRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof apiV2EncounterMethodRetrieve>>,
  TError = unknown,
>(
  id: string,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterMethodRetrieve>>, TError, TData>
    >;
  },
) => {
  const { fetch: fetchOptions, query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getApiV2EncounterMethodRetrieveQueryKey(id);

  const queryFunction: QueryFunction<Awaited<ReturnType<typeof apiV2EncounterMethodRetrieve>>> = ({
    signal,
  }) => apiV2EncounterMethodRetrieve(id, { signal, ...fetchOptions });

  return { enabled: !!id, queryFn: queryFunction, queryKey, ...queryOptions } as {
    queryKey: DataTag<QueryKey, TData, TError>;
  } & UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterMethodRetrieve>>, TError, TData>;
};

export type apiV2EncounterConditionListResponse = apiV2EncounterConditionListResponseSuccess;
/**
 * Conditions which affect what pokemon might appear in the wild, e.g., day or night.
 * @summary List encounter conditions
 */
export type apiV2EncounterConditionListResponse200 = {
  data: PaginatedEncounterConditionSummaryList;
  status: 200;
};

export type apiV2EncounterConditionListResponseSuccess = {
  headers: Headers;
} & apiV2EncounterConditionListResponse200;
export type ApiV2EncounterMethodRetrieveQueryError = unknown;
export type ApiV2EncounterMethodRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof apiV2EncounterMethodRetrieve>>
>;
/**
 * @summary Get encounter method
 */

export function useApiV2EncounterMethodRetrieve<
  TData = Awaited<ReturnType<typeof apiV2EncounterMethodRetrieve>>,
  TError = unknown,
>(
  id: string,
  options: {
    fetch?: RequestInit;
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterMethodRetrieve>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV2EncounterMethodRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiV2EncounterMethodRetrieve>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & DefinedUseQueryResult<TData, TError>;

export function useApiV2EncounterMethodRetrieve<
  TData = Awaited<ReturnType<typeof apiV2EncounterMethodRetrieve>>,
  TError = unknown,
>(
  id: string,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterMethodRetrieve>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV2EncounterMethodRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiV2EncounterMethodRetrieve>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError>;

export function useApiV2EncounterMethodRetrieve<
  TData = Awaited<ReturnType<typeof apiV2EncounterMethodRetrieve>>,
  TError = unknown,
>(
  id: string,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterMethodRetrieve>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError>;
export function useApiV2EncounterMethodRetrieve<
  TData = Awaited<ReturnType<typeof apiV2EncounterMethodRetrieve>>,
  TError = unknown,
>(
  id: string,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterMethodRetrieve>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError> {
  const queryOptions = getApiV2EncounterMethodRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as {
    queryKey: DataTag<QueryKey, TData, TError>;
  } & UseQueryResult<TData, TError>;

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getApiV2EncounterConditionListUrl = (
  parameters?: ApiV2EncounterConditionListParameters,
) => {
  const normalizedParameters = new URLSearchParams();

  for (const [key, value] of Object.entries(parameters || {})) {
    if (value !== undefined) {
      normalizedParameters.append(key, value === null ? 'null' : value.toString());
    }
  }

  const stringifiedParameters = normalizedParameters.toString();

  return stringifiedParameters.length > 0
    ? `/api/v2/encounter-condition/?${stringifiedParameters}`
    : `/api/v2/encounter-condition/`;
};

export const apiV2EncounterConditionList = async (
  parameters?: ApiV2EncounterConditionListParameters,
  options?: RequestInit,
): Promise<apiV2EncounterConditionListResponse> => {
  const res = await fetch(getApiV2EncounterConditionListUrl(parameters), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: apiV2EncounterConditionListResponse['data'] = body ? JSON.parse(body) : {};
  return { data, headers: res.headers, status: res.status } as apiV2EncounterConditionListResponse;
};

export const getApiV2EncounterConditionListQueryKey = (
  parameters?: ApiV2EncounterConditionListParameters,
) => {
  return [`/api/v2/encounter-condition/`, ...(parameters ? [parameters] : [])] as const;
};

export const getApiV2EncounterConditionListQueryOptions = <
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionList>>,
  TError = unknown,
>(
  parameters?: ApiV2EncounterConditionListParameters,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterConditionList>>, TError, TData>
    >;
  },
) => {
  const { fetch: fetchOptions, query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getApiV2EncounterConditionListQueryKey(parameters);

  const queryFunction: QueryFunction<Awaited<ReturnType<typeof apiV2EncounterConditionList>>> = ({
    signal,
  }) => apiV2EncounterConditionList(parameters, { signal, ...fetchOptions });

  return { queryFn: queryFunction, queryKey, ...queryOptions } as {
    queryKey: DataTag<QueryKey, TData, TError>;
  } & UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterConditionList>>, TError, TData>;
};

export type ApiV2EncounterConditionListQueryError = unknown;
export type ApiV2EncounterConditionListQueryResult = NonNullable<
  Awaited<ReturnType<typeof apiV2EncounterConditionList>>
>;

export type apiV2EncounterConditionRetrieveResponse =
  apiV2EncounterConditionRetrieveResponseSuccess;
/**
 * Conditions which affect what pokemon might appear in the wild, e.g., day or night.
 * @summary Get encounter condition
 */
export type apiV2EncounterConditionRetrieveResponse200 = {
  data: EncounterConditionDetail;
  status: 200;
};
export type apiV2EncounterConditionRetrieveResponseSuccess = {
  headers: Headers;
} & apiV2EncounterConditionRetrieveResponse200;
/**
 * @summary List encounter conditions
 */

export function useApiV2EncounterConditionList<
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionList>>,
  TError = unknown,
>(
  parameters: ApiV2EncounterConditionListParameters | undefined,
  options: {
    fetch?: RequestInit;
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterConditionList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV2EncounterConditionList>>,
          TError,
          Awaited<ReturnType<typeof apiV2EncounterConditionList>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & DefinedUseQueryResult<TData, TError>;

export function useApiV2EncounterConditionList<
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionList>>,
  TError = unknown,
>(
  parameters?: ApiV2EncounterConditionListParameters,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterConditionList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV2EncounterConditionList>>,
          TError,
          Awaited<ReturnType<typeof apiV2EncounterConditionList>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError>;

export function useApiV2EncounterConditionList<
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionList>>,
  TError = unknown,
>(
  parameters?: ApiV2EncounterConditionListParameters,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterConditionList>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError>;
export function useApiV2EncounterConditionList<
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionList>>,
  TError = unknown,
>(
  parameters?: ApiV2EncounterConditionListParameters,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterConditionList>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError> {
  const queryOptions = getApiV2EncounterConditionListQueryOptions(parameters, options);

  const query = useQuery(queryOptions, queryClient) as {
    queryKey: DataTag<QueryKey, TData, TError>;
  } & UseQueryResult<TData, TError>;

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getApiV2EncounterConditionRetrieveUrl = (id: string) => {
  return `/api/v2/encounter-condition/${id}/`;
};

export const apiV2EncounterConditionRetrieve = async (
  id: string,
  options?: RequestInit,
): Promise<apiV2EncounterConditionRetrieveResponse> => {
  const res = await fetch(getApiV2EncounterConditionRetrieveUrl(id), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: apiV2EncounterConditionRetrieveResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as apiV2EncounterConditionRetrieveResponse;
};

export const getApiV2EncounterConditionRetrieveQueryKey = (id?: string) => {
  return [`/api/v2/encounter-condition/${id}/`] as const;
};

export const getApiV2EncounterConditionRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionRetrieve>>,
  TError = unknown,
>(
  id: string,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterConditionRetrieve>>, TError, TData>
    >;
  },
) => {
  const { fetch: fetchOptions, query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getApiV2EncounterConditionRetrieveQueryKey(id);

  const queryFunction: QueryFunction<
    Awaited<ReturnType<typeof apiV2EncounterConditionRetrieve>>
  > = ({ signal }) => apiV2EncounterConditionRetrieve(id, { signal, ...fetchOptions });

  return { enabled: !!id, queryFn: queryFunction, queryKey, ...queryOptions } as {
    queryKey: DataTag<QueryKey, TData, TError>;
  } & UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterConditionRetrieve>>, TError, TData>;
};

export type ApiV2EncounterConditionRetrieveQueryError = unknown;
export type ApiV2EncounterConditionRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof apiV2EncounterConditionRetrieve>>
>;

export type apiV2EncounterConditionValueListResponse =
  apiV2EncounterConditionValueListResponseSuccess;
/**
 * Encounter condition values are the various states that an encounter condition can have, i.e., time of day can be either day or night.
 * @summary List encounter condition values
 */
export type apiV2EncounterConditionValueListResponse200 = {
  data: PaginatedEncounterConditionValueSummaryList;
  status: 200;
};
export type apiV2EncounterConditionValueListResponseSuccess = {
  headers: Headers;
} & apiV2EncounterConditionValueListResponse200;
/**
 * @summary Get encounter condition
 */

export function useApiV2EncounterConditionRetrieve<
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionRetrieve>>,
  TError = unknown,
>(
  id: string,
  options: {
    fetch?: RequestInit;
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterConditionRetrieve>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV2EncounterConditionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiV2EncounterConditionRetrieve>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & DefinedUseQueryResult<TData, TError>;

export function useApiV2EncounterConditionRetrieve<
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionRetrieve>>,
  TError = unknown,
>(
  id: string,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterConditionRetrieve>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV2EncounterConditionRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiV2EncounterConditionRetrieve>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError>;

export function useApiV2EncounterConditionRetrieve<
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionRetrieve>>,
  TError = unknown,
>(
  id: string,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterConditionRetrieve>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError>;
export function useApiV2EncounterConditionRetrieve<
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionRetrieve>>,
  TError = unknown,
>(
  id: string,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterConditionRetrieve>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError> {
  const queryOptions = getApiV2EncounterConditionRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as {
    queryKey: DataTag<QueryKey, TData, TError>;
  } & UseQueryResult<TData, TError>;

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getApiV2EncounterConditionValueListUrl = (
  parameters?: ApiV2EncounterConditionValueListParameters,
) => {
  const normalizedParameters = new URLSearchParams();

  for (const [key, value] of Object.entries(parameters || {})) {
    if (value !== undefined) {
      normalizedParameters.append(key, value === null ? 'null' : value.toString());
    }
  }

  const stringifiedParameters = normalizedParameters.toString();

  return stringifiedParameters.length > 0
    ? `/api/v2/encounter-condition-value/?${stringifiedParameters}`
    : `/api/v2/encounter-condition-value/`;
};

export const apiV2EncounterConditionValueList = async (
  parameters?: ApiV2EncounterConditionValueListParameters,
  options?: RequestInit,
): Promise<apiV2EncounterConditionValueListResponse> => {
  const res = await fetch(getApiV2EncounterConditionValueListUrl(parameters), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: apiV2EncounterConditionValueListResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as apiV2EncounterConditionValueListResponse;
};

export const getApiV2EncounterConditionValueListQueryKey = (
  parameters?: ApiV2EncounterConditionValueListParameters,
) => {
  return [`/api/v2/encounter-condition-value/`, ...(parameters ? [parameters] : [])] as const;
};

export const getApiV2EncounterConditionValueListQueryOptions = <
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionValueList>>,
  TError = unknown,
>(
  parameters?: ApiV2EncounterConditionValueListParameters,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterConditionValueList>>, TError, TData>
    >;
  },
) => {
  const { fetch: fetchOptions, query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getApiV2EncounterConditionValueListQueryKey(parameters);

  const queryFunction: QueryFunction<
    Awaited<ReturnType<typeof apiV2EncounterConditionValueList>>
  > = ({ signal }) => apiV2EncounterConditionValueList(parameters, { signal, ...fetchOptions });

  return { queryFn: queryFunction, queryKey, ...queryOptions } as {
    queryKey: DataTag<QueryKey, TData, TError>;
  } & UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterConditionValueList>>, TError, TData>;
};

export type ApiV2EncounterConditionValueListQueryError = unknown;
export type ApiV2EncounterConditionValueListQueryResult = NonNullable<
  Awaited<ReturnType<typeof apiV2EncounterConditionValueList>>
>;

export type apiV2EncounterConditionValueRetrieveResponse =
  apiV2EncounterConditionValueRetrieveResponseSuccess;
/**
 * Encounter condition values are the various states that an encounter condition can have, i.e., time of day can be either day or night.
 * @summary Get encounter condition value
 */
export type apiV2EncounterConditionValueRetrieveResponse200 = {
  data: EncounterConditionValueDetail;
  status: 200;
};
export type apiV2EncounterConditionValueRetrieveResponseSuccess = {
  headers: Headers;
} & apiV2EncounterConditionValueRetrieveResponse200;
/**
 * @summary List encounter condition values
 */

export function useApiV2EncounterConditionValueList<
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionValueList>>,
  TError = unknown,
>(
  parameters: ApiV2EncounterConditionValueListParameters | undefined,
  options: {
    fetch?: RequestInit;
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterConditionValueList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV2EncounterConditionValueList>>,
          TError,
          Awaited<ReturnType<typeof apiV2EncounterConditionValueList>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & DefinedUseQueryResult<TData, TError>;

export function useApiV2EncounterConditionValueList<
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionValueList>>,
  TError = unknown,
>(
  parameters?: ApiV2EncounterConditionValueListParameters,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterConditionValueList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV2EncounterConditionValueList>>,
          TError,
          Awaited<ReturnType<typeof apiV2EncounterConditionValueList>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError>;

export function useApiV2EncounterConditionValueList<
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionValueList>>,
  TError = unknown,
>(
  parameters?: ApiV2EncounterConditionValueListParameters,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterConditionValueList>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError>;
export function useApiV2EncounterConditionValueList<
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionValueList>>,
  TError = unknown,
>(
  parameters?: ApiV2EncounterConditionValueListParameters,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2EncounterConditionValueList>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError> {
  const queryOptions = getApiV2EncounterConditionValueListQueryOptions(parameters, options);

  const query = useQuery(queryOptions, queryClient) as {
    queryKey: DataTag<QueryKey, TData, TError>;
  } & UseQueryResult<TData, TError>;

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getApiV2EncounterConditionValueRetrieveUrl = (id: string) => {
  return `/api/v2/encounter-condition-value/${id}/`;
};

export const apiV2EncounterConditionValueRetrieve = async (
  id: string,
  options?: RequestInit,
): Promise<apiV2EncounterConditionValueRetrieveResponse> => {
  const res = await fetch(getApiV2EncounterConditionValueRetrieveUrl(id), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: apiV2EncounterConditionValueRetrieveResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as apiV2EncounterConditionValueRetrieveResponse;
};

export const getApiV2EncounterConditionValueRetrieveQueryKey = (id?: string) => {
  return [`/api/v2/encounter-condition-value/${id}/`] as const;
};

export const getApiV2EncounterConditionValueRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionValueRetrieve>>,
  TError = unknown,
>(
  id: string,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiV2EncounterConditionValueRetrieve>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { fetch: fetchOptions, query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getApiV2EncounterConditionValueRetrieveQueryKey(id);

  const queryFunction: QueryFunction<
    Awaited<ReturnType<typeof apiV2EncounterConditionValueRetrieve>>
  > = ({ signal }) => apiV2EncounterConditionValueRetrieve(id, { signal, ...fetchOptions });

  return { enabled: !!id, queryFn: queryFunction, queryKey, ...queryOptions } as {
    queryKey: DataTag<QueryKey, TData, TError>;
  } & UseQueryOptions<
    Awaited<ReturnType<typeof apiV2EncounterConditionValueRetrieve>>,
    TError,
    TData
  >;
};

export type ApiV2EncounterConditionValueRetrieveQueryError = unknown;
export type ApiV2EncounterConditionValueRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof apiV2EncounterConditionValueRetrieve>>
>;

export type apiV2PokemonEncountersRetrieveResponse = apiV2PokemonEncountersRetrieveResponseSuccess;
/**
 * Handles Pokemon Encounters as a sub-resource.
 * @summary Get pokemon encounter
 */
export type apiV2PokemonEncountersRetrieveResponse200 = {
  data: ApiV2PokemonEncountersRetrieve200Item[];
  status: 200;
};
export type apiV2PokemonEncountersRetrieveResponseSuccess = {
  headers: Headers;
} & apiV2PokemonEncountersRetrieveResponse200;
/**
 * @summary Get encounter condition value
 */

export function useApiV2EncounterConditionValueRetrieve<
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionValueRetrieve>>,
  TError = unknown,
>(
  id: string,
  options: {
    fetch?: RequestInit;
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiV2EncounterConditionValueRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV2EncounterConditionValueRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiV2EncounterConditionValueRetrieve>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & DefinedUseQueryResult<TData, TError>;

export function useApiV2EncounterConditionValueRetrieve<
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionValueRetrieve>>,
  TError = unknown,
>(
  id: string,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiV2EncounterConditionValueRetrieve>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV2EncounterConditionValueRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiV2EncounterConditionValueRetrieve>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError>;

export function useApiV2EncounterConditionValueRetrieve<
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionValueRetrieve>>,
  TError = unknown,
>(
  id: string,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiV2EncounterConditionValueRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError>;
export function useApiV2EncounterConditionValueRetrieve<
  TData = Awaited<ReturnType<typeof apiV2EncounterConditionValueRetrieve>>,
  TError = unknown,
>(
  id: string,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof apiV2EncounterConditionValueRetrieve>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError> {
  const queryOptions = getApiV2EncounterConditionValueRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as {
    queryKey: DataTag<QueryKey, TData, TError>;
  } & UseQueryResult<TData, TError>;

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getApiV2PokemonEncountersRetrieveUrl = (pokemonId: string) => {
  return `/api/v2/pokemon/${pokemonId}/encounters`;
};

export const apiV2PokemonEncountersRetrieve = async (
  pokemonId: string,
  options?: RequestInit,
): Promise<apiV2PokemonEncountersRetrieveResponse> => {
  const res = await fetch(getApiV2PokemonEncountersRetrieveUrl(pokemonId), {
    ...options,
    method: 'GET',
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: apiV2PokemonEncountersRetrieveResponse['data'] = body ? JSON.parse(body) : {};
  return {
    data,
    headers: res.headers,
    status: res.status,
  } as apiV2PokemonEncountersRetrieveResponse;
};

export const getApiV2PokemonEncountersRetrieveQueryKey = (pokemonId?: string) => {
  return [`/api/v2/pokemon/${pokemonId}/encounters`] as const;
};

export const getApiV2PokemonEncountersRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof apiV2PokemonEncountersRetrieve>>,
  TError = unknown,
>(
  pokemonId: string,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2PokemonEncountersRetrieve>>, TError, TData>
    >;
  },
) => {
  const { fetch: fetchOptions, query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getApiV2PokemonEncountersRetrieveQueryKey(pokemonId);

  const queryFunction: QueryFunction<
    Awaited<ReturnType<typeof apiV2PokemonEncountersRetrieve>>
  > = ({ signal }) => apiV2PokemonEncountersRetrieve(pokemonId, { signal, ...fetchOptions });

  return { enabled: !!pokemonId, queryFn: queryFunction, queryKey, ...queryOptions } as {
    queryKey: DataTag<QueryKey, TData, TError>;
  } & UseQueryOptions<Awaited<ReturnType<typeof apiV2PokemonEncountersRetrieve>>, TError, TData>;
};

export type ApiV2PokemonEncountersRetrieveQueryError = unknown;
export type ApiV2PokemonEncountersRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof apiV2PokemonEncountersRetrieve>>
>;

export function useApiV2PokemonEncountersRetrieve<
  TData = Awaited<ReturnType<typeof apiV2PokemonEncountersRetrieve>>,
  TError = unknown,
>(
  pokemonId: string,
  options: {
    fetch?: RequestInit;
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2PokemonEncountersRetrieve>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV2PokemonEncountersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiV2PokemonEncountersRetrieve>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & DefinedUseQueryResult<TData, TError>;
export function useApiV2PokemonEncountersRetrieve<
  TData = Awaited<ReturnType<typeof apiV2PokemonEncountersRetrieve>>,
  TError = unknown,
>(
  pokemonId: string,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2PokemonEncountersRetrieve>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV2PokemonEncountersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiV2PokemonEncountersRetrieve>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError>;
export function useApiV2PokemonEncountersRetrieve<
  TData = Awaited<ReturnType<typeof apiV2PokemonEncountersRetrieve>>,
  TError = unknown,
>(
  pokemonId: string,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2PokemonEncountersRetrieve>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError>;
/**
 * @summary Get pokemon encounter
 */

export function useApiV2PokemonEncountersRetrieve<
  TData = Awaited<ReturnType<typeof apiV2PokemonEncountersRetrieve>>,
  TError = unknown,
>(
  pokemonId: string,
  options?: {
    fetch?: RequestInit;
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiV2PokemonEncountersRetrieve>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): { queryKey: DataTag<QueryKey, TData, TError> } & UseQueryResult<TData, TError> {
  const queryOptions = getApiV2PokemonEncountersRetrieveQueryOptions(pokemonId, options);

  const query = useQuery(queryOptions, queryClient) as {
    queryKey: DataTag<QueryKey, TData, TError>;
  } & UseQueryResult<TData, TError>;

  query.queryKey = queryOptions.queryKey;

  return query;
}
